// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#param is_fp16
#param k

const K: u32 = k;
#if is_fp16
const MAX_FLOAT: f16 = 65504.0;
#else
const MAX_FLOAT: f32 = 3.402823466e+38;
#endif
var<workgroup> shared_vals: array<input_element_t, workgroup_size_x>;
var<workgroup> shared_idxs: array<u32, workgroup_size_x>;

$MAIN {
    let row = workgroup_id.x;
    if (row >= uniforms.rows) { return; }
    let tid = local_id.x;
    let cols = uniforms.cols;
    let base = row * cols;

    var max_val: input_element_t = -MAX_FLOAT;
    var max_idx: u32 = 0u;

    if (tid < cols) {
        max_val = input[base + tid];
        max_idx = tid;
    }
    shared_vals[tid] = max_val;
    shared_idxs[tid] = max_idx;
    workgroupBarrier();

    // K is very small, use a simple bubble sort
    for (var i = 0u; i < workgroup_size_x - 1u; i++) {
        for (var j = 0u; j < workgroup_size_x - 1u - i; j++) {
            if (tid == j && tid < cols && (tid + 1u) < cols) {
                // Compare adjacent elements and swap if needed (descending order)
                if (shared_vals[tid] < shared_vals[tid + 1u]) {
                    let temp_val = shared_vals[tid];
                    let temp_idx = shared_idxs[tid];
                    shared_vals[tid] = shared_vals[tid + 1u];
                    shared_idxs[tid] = shared_idxs[tid + 1u];
                    shared_vals[tid + 1u] = temp_val;
                    shared_idxs[tid + 1u] = temp_idx;
                }
            }
            workgroupBarrier();
        }
    }
    if (tid < K) {
        let output_base = row * K;
        if (tid < cols) {
            let idx = shared_idxs[tid];
            topk_indices_fc1[output_base + tid].x = 0u;
            topk_indices_fc1[output_base + tid].y = idx;
            topk_indices_fc1[output_base + tid].z = row * K + tid;
            topk_indices_fc1[output_base + tid].w = 99u;

            topk_indices_fc2[output_base + tid].x = tid;
            topk_indices_fc2[output_base + tid].y = idx;
            topk_indices_fc2[output_base + tid].z = row * K + tid;
            topk_indices_fc2[output_base + tid].w = 99u;
        }
    }
    workgroupBarrier();
    if (tid == 0u) {
        let output_base = row * K;
        var sum : f32 = 0.0;
        for (var i = 0u; i < K; i++) {
            sum += exp(f32(shared_vals[i]));
        }
        for (var i = 0u; i < K; i++) {
            topk_values[output_base + i] = topk_values_value_t(exp(f32(shared_vals[i])) / sum);
        }
    }
} // MAIN
